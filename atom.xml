<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Is you</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://pathfinderk.github.io/"/>
  <updated>2019-01-02T03:27:04.847Z</updated>
  <id>http://pathfinderk.github.io/</id>
  
  <author>
    <name>Pan Kai</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>程序设计语言原理复习（2）</title>
    <link href="http://pathfinderk.github.io/2019/01/02/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E4%BA%8C/"/>
    <id>http://pathfinderk.github.io/2019/01/02/程序语言设计原理复习二/</id>
    <published>2019-01-02T01:52:27.964Z</published>
    <updated>2019-01-02T03:27:04.847Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Chapter-5-Names-Bindings-Type-Checking-and-Scopes-作用域"><a href="#Chapter-5-Names-Bindings-Type-Checking-and-Scopes-作用域" class="headerlink" title="Chapter 5 Names, Bindings, Type Checking, and Scopes(作用域)"></a>Chapter 5 Names, Bindings, Type Checking, and Scopes(作用域)</h1><h2 id="Variables-变量"><a href="#Variables-变量" class="headerlink" title="Variables 变量"></a>Variables 变量</h2><p> 1.A variable is an abstraction of a memory cel变量是存储单元<br> 2.Variables can be characterized as a sextuple(六个部分) of attributes:（name, address, value, type,  lifetime（生存周期）, scope（作用域）)刻画一个变量<br> 的6个特征 </p><h2 id="Binding-绑定"><a href="#Binding-绑定" class="headerlink" title="Binding 绑定"></a>Binding 绑定</h2><ol><li>The l-value of a variable is its address左值是地址</li><li>The r-value of a variable is its value右值是数值<br> Def: A binding is an association(关联), such as between an attribute(属性) and an entity, or between an operation and a symbol.<br> Def: Binding time is the time at which a binding takes place.</li><li>Possible binding times:<br>Language design time–e.g., bind operator symbols to operations. (+)语言设计时<br>Language implementation time–e.g., bind data type to a range of possible value. (integer)语言实现时<br>Compile time–e.g., bind a variable to a type in C or Java.编译时<br>Link time—a call to a library subprogram is bound o the subprogram code连接时<br>Load time–e.g., bind a FORTRAN 77 variable to a memory cell (or a C static variable).载入时<br>Runtime–e.g., bind a non-static local variable to a memory cell.运行时</li><li><p>Binding of Attributes to variables<br>Def: A binding is static if it first occurs before run time and remains unchanged throughout program execution.</p><p>Def: A binding is dynamic if it first occurs during execution or can change during execution of the program.</p></li><li>Storage Bindings &amp; Lifetime<br>5.1<br> Static–bound to memory cells before execution begins and remains bound to the same memory cell throughout execution静态绑定在执行开始之前绑定到存储器单元，并在整个执行期间保持绑定到同一存储器单元。<br> Advantages: efficiency  (direct addressing)直接寻址, history-sensitive subprogram support<br> Disadvantage: lack of flexibility  (no recursion)没有递归<br> The storage cannot be shared among variables.<br>5.2<br> Stack-dynamic–Storage bindings are created for variables when their declaration statements are elaborated（描述）.<br> Advantage: allows recursion;<br> Disadvantages:<br>  Overhead of allocation and deallocation(解除分配)分配和解除分配的开销（解除分配）<br>  Subprograms cannot be history sensitive<br>  子程序不能对历史敏感<br>  Inefficient references (indirect addressing)<br>  效率低下的引用（间接寻址）<br>5.3<br> Explicit heap-dynamic–Allocated and deallocated by explicit directives, specified by the programmer, which take effect during execution<br>  显式堆动态 - 由程序员指定的显式指令分配和取消分配，这些指令在执行期间生效<br> Referenced only through pointers or references<br> e.g. dynamic objects in C++ (via new and delete)<br> all objects in Java<br> dvantage: provides for dynamic storage management动态存储<br>  Disadvantage: inefficient and unreliable效率低下不可靠<br>5.4<br> Implicit heap-dynamic–Allocation and deallocation caused by assignment statements<br> 隐式堆动态 - 赋值语句引起的分配和释放<br> e.g. all variables in APL; all strings and arrays in Perl and JavaScript<br> Advantage: flexibility<br> Disadvantages:<br> Inefficient, because all attributes are dynamic<br> Loss of error detection<br> 效率低下，因为所有属性都是动态的<br> 丢失错误检测</li></ol><h2 id="Type-Checking"><a href="#Type-Checking" class="headerlink" title="Type Checking"></a>Type Checking</h2><pre><code>Type checking is the activity of ensuring that the operands of an operator are of compatible types类型检查是确保运算符的操作数是兼容类型的活动</code></pre><h2 id="Strong-Typing"><a href="#Strong-Typing" class="headerlink" title="Strong Typing"></a>Strong Typing</h2><pre><code>Advantage of strong typing: allows the detection of the misuses of variables that result in type errors强化类型的优点：允许检测导致类型错误的变量的误用</code></pre><h2 id="Type-Compatibility-等价类型"><a href="#Type-Compatibility-等价类型" class="headerlink" title="Type Compatibility 等价类型"></a>Type Compatibility 等价类型</h2><ol><li>Name type compatibility 按名等价<br>  Name type compatibility means the two  variables have compatible types if they are in either the same declaration or in declarations that use the same type name<br>  名称类型兼容性是指两个变量具有兼容类型（如果它们位于相同的声明中或使用相同类型名称的声明中）</li><li>declaration equivalence 按定义等价<br> 两个变量具有按定义等价的类型当且仅当两个变量有完全相同的类型（包括相同的域名）</li><li>Structure type compatibility 按结构等价<br> 两个变量的类型具有相同的（一样）结构，则它们具有兼容的类型<br> 更灵活，但更难实施</li></ol><h2 id="Scope-作用域"><a href="#Scope-作用域" class="headerlink" title="Scope 作用域"></a>Scope 作用域</h2><ol><li>静态作用域<br>静态作用域又分为两类，一类是子程序可以嵌套，一类是不可以嵌套</li><li>动态作用域<br>动态作用域基于子程序的调用序列，而不是基于作用域互相之间的空间关系。因此动态作用域只能在运行时得已确定。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Chapter-5-Names-Bindings-Type-Checking-and-Scopes-作用域&quot;&gt;&lt;a href=&quot;#Chapter-5-Names-Bindings-Type-Checking-and-Scopes-作用域&quot; class=&quot;heade
      
    
    </summary>
    
    
      <category term="Final Review" scheme="http://pathfinderk.github.io/tags/Final-Review/"/>
    
  </entry>
  
  <entry>
    <title>程序设计语言原理复习（1）</title>
    <link href="http://pathfinderk.github.io/2019/01/01/fianl_tset%20review2/"/>
    <id>http://pathfinderk.github.io/2019/01/01/fianl_tset review2/</id>
    <published>2019-01-01T02:00:26.031Z</published>
    <updated>2019-01-02T03:21:52.731Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Chapter-1-Preliminaries-基本概念"><a href="#Chapter-1-Preliminaries-基本概念" class="headerlink" title="Chapter 1: Preliminaries(基本概念)"></a>Chapter 1: Preliminaries(基本概念)</h1><h2 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h2><p>  1.增进思想表达的能力<br>  2.增强选择适用语言的能力<br>  3.增强学习新的语言的呢能力<br>  4.更好的理解现实的重要性<br>  5.更好的使用已知语言<br>  6.促进整个计算机科学的发展</p><h2 id="Programming-Domains-领域"><a href="#Programming-Domains-领域" class="headerlink" title="Programming Domains(领域)"></a>Programming Domains(领域)</h2><p> 可以用科学，商务，人工智能，程序设计，万维网语言</p><h2 id="Language-Evaluation-Criteria-语言评估标准-重点"><a href="#Language-Evaluation-Criteria-语言评估标准-重点" class="headerlink" title="Language Evaluation Criteria(语言评估标准)//重点"></a>Language Evaluation Criteria(语言评估标准)//重点</h2><p> 1.可读性  包括<code>简单整体性</code> <code>正交性</code> <code>控制语句</code> <code>数据类型与数据结构</code> <code>语法设计</code>  其中正交性：指只用该语言的一组相对少量的基本结构，经过相对少的结合步骤，就可构成该语言的控制结构和数据结构。而且，它的基本结构的任何组合都是合法和有意义的<br> 2.可写性 <code>简单性与正交性</code>  <code>支持抽象</code>  <code>表达性</code><br> 3.可靠性 <code>类型检测</code>  <code>异常处理</code>  <code>使用别名</code> <code>可读性与可写性</code><br> 4.代价 </p><h2 id="Influences-on-Language-Design-影响语言设计的因素-重点"><a href="#Influences-on-Language-Design-影响语言设计的因素-重点" class="headerlink" title="Influences on Language Design(影响语言设计的因素)//重点"></a>Influences on Language Design(影响语言设计的因素)//重点</h2><p>  1.计算机体系结构<br>  2.程序设计方法</p><h2 id="Language-Categories-语言分类"><a href="#Language-Categories-语言分类" class="headerlink" title="Language Categories(语言分类)"></a>Language Categories(语言分类)</h2><p>  1.Imperative(命令式)<br>   -Central features are variables, assignment statements, and iteration<br>   -C, Pascal<br>  2.Functional<br>   -Main means of making computations is by applying functions to given parameters<br>   -LISP, Scheme<br>  3.Logic(逻辑式)<br>   -Rule-based<br>   -Rules are specified in no special order<br>   -Prolog<br>  4.Object-oriented(面向对象)<br>   -Encapsulate data objects with processing<br>   Inheritance and dynamic type binding<br>   Grew out of imperative languages<br>   -C++, Java</p><h1 id="Chapter-2-Evolution-of-the-major-programming-languages"><a href="#Chapter-2-Evolution-of-the-major-programming-languages" class="headerlink" title="Chapter 2: Evolution of the major programming languages"></a>Chapter 2: Evolution of the major programming languages</h1><h2 id="The-IBM-704-and-FORTRAN"><a href="#The-IBM-704-and-FORTRAN" class="headerlink" title="The IBM 704 and FORTRAN"></a>The IBM 704 and FORTRAN</h2><p> 概要：Designed for the new IBM 704, which had index registers（索引寄存器）and floating point hardware（浮点硬件)<br>   Environment of development<br>   -Computers were small and unreliable（计算机很小，不可靠）<br>   -Applications were scientific（应用是科学的）<br>   -No programming methodology or tools（没有编程方法或工具）<br>   -Machine efficiency was most important（机器效率最重要）</p><h2 id="The-First-Step-Toward-Sophistication-ALGOL-60"><a href="#The-First-Step-Toward-Sophistication-ALGOL-60" class="headerlink" title="The First Step Toward Sophistication: ALGOL 60"></a>The First Step Toward Sophistication: ALGOL 60</h2><p>  new feature:<br>    Block structure (local scope)块结构<br>    Two parameter passing methods (pass by value and pass by name)两种不同方式经行子程序的参数传递<br>    Subprogram recursion 递归<br>    Stack-dynamic arrays 栈动态数组<br>    Still no I/O and no string handling缺乏输入与输出 导致ALGOL无法被广泛应用</p><h2 id="The-Beginning-of-Data-Abstraction-SIMULA-67"><a href="#The-Beginning-of-Data-Abstraction-SIMULA-67" class="headerlink" title="The Beginning of Data Abstraction: SIMULA 67"></a>The Beginning of Data Abstraction: SIMULA 67</h2><p>  Designed primarily for system simulation(仿真) in Norway by Nygaard and Dahl<br>  Based on ALGOL 60 and SIMULA I<br>  Primary Contributions：<br>  Co-routines(协同程序) - a kind of subprogram<br>  Implemented in a structure called a class<br>  Classes are the basis for data abstraction<br>  Classes are structures that include both local data and functionality</p><h2 id="History’s-Largest-Design-Effort-Ada-最大规模的语言设计"><a href="#History’s-Largest-Design-Effort-Ada-最大规模的语言设计" class="headerlink" title="History’s Largest Design Effort: Ada 最大规模的语言设计"></a>History’s Largest Design Effort: Ada 最大规模的语言设计</h2><p>  Contributions<br> Packages - support for data abstraction提供数据的封装<br> Exception handling - elaborate (详细描述)异常处理机制<br> Generic program units程序单元通用<br> Concurrency - through the tasking model 提供并发</p><h2 id="Object-Oriented-Programming-Smalltalk-面向对象的程序设计"><a href="#Object-Oriented-Programming-Smalltalk-面向对象的程序设计" class="headerlink" title="Object-Oriented Programming: Smalltalk 面向对象的程序设计"></a>Object-Oriented Programming: Smalltalk 面向对象的程序设计</h2><p> First full implementation of an object-oriented language (data abstraction, inheritance, and dynamic type binding)首先完全实现面向对象的语言（数据抽象，继承和动态类型绑定）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Chapter-1-Preliminaries-基本概念&quot;&gt;&lt;a href=&quot;#Chapter-1-Preliminaries-基本概念&quot; class=&quot;headerlink&quot; title=&quot;Chapter 1: Preliminaries(基本概念)&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
    
      <category term="Final Review" scheme="http://pathfinderk.github.io/tags/Final-Review/"/>
    
  </entry>
  
</feed>
